{"module":"contract","action":"verifysourcecode","codeformat":"solidity-standard-json-input","contractaddress":"0xd3B1D32E9632b77aDD2FcF57FCeEEA16b1eff188","compilerversion":"v0.8.25+commit.b61c2a91","contractname":"Staking.sol:Staking","evmVersion":"","licenseType":1,"sourceCode":"{\"language\":\"Solidity\",\"settings\":{\"optimizer\":{\"enabled\":false,\"runs\":200}},\"sources\":{\"Staking.sol\":{\"content\":\"// SPDX-License-Identifier: Ecosystem\\n\\npragma solidity 0.8.25;\\n\\nimport \\\"./TournamentScores.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\n\\n//TODO: malicious owner of tournament could potentially steal peoples money (need a fix for this), some ecdsa between backend server and contract\\n// the server could have a special signature for hashing certain parts\\n//TODO: add a way if something went wrong in tournament and couldn't finish to reimburse money\\n//TODO: add checks for tournament and user ids if out of bounds\\n\\ncontract Staking is TournamentScores, ReentrancyGuard {\\n\\n\\n\\t//events ######################\\n\\tevent tournamentCreated(string msg1, uint256 id_tournament, string msg2, uint256 amount_staked);\\n\\tevent StakeSuccess(string msg1, uint256 id_tournament, string msg2, uint256 amount_staked);\\n\\tevent StakeGoalReached(string msg1, uint256 id_tournament, string msg2, uint256 amount_staked);\\n\\tevent timeForStakePassed(string msg);\\n\\tevent reimbursedStakes(string msg);\\n\\tevent restTransferToOwner(string msg);\\n\\tevent tournamentStarted(string msg, uint256 tour_id);\\n\\n\\t//errors ######################\\n\\t// error numberToHigh(string msg, uint256 NofPlayers);\\n\\t// error indexOutOfBounds(string msg, uint256 passedIndex);\\n\\terror insufficientAmount(string msg, uint256 amount);\\n\\terror tournamentAlreadyFinished(string msg, uint256 tournament_id);\\n\\terror wrongUsersPassed(string msg, uint256[8] user_ids);\\n\\terror wrongUser(string msg, uint256 user_id);\\n\\terror timePassed(string msg, uint256 tour_id);\\n\\terror tournamentInProgress(string msg, uint256 tournament_id);\\n\\n\\t//structs ######################\\n\\tstruct user {\\n\\t\\tuint256\\tuser_id;\\n\\t\\tstring\\tusername;\\n\\t\\taddress user_wallet;\\n\\t} //player info\\n\\n\\tstruct\\tpayableTournament {\\n\\t\\tuint256\\tNofPlayers;\\n\\t\\tuint256[8]\\tuser_ids;\\n\\t\\tuint256\\tmin_stake;\\n\\t\\tuint256\\tstake_goal;\\n\\t\\tbool\\tis_finished;\\n\\t\\tbool\\thas_started;\\n\\t\\tbool\\tis_reimbursed;\\n\\t\\tuint256\\tcreated_at;\\n\\t} // created tournament info\\n\\n\\tstruct Pair {\\n\\t\\t\\tuint256 user_score;\\n\\t\\t\\tuint256\\tuser_id;\\n\\t} // for placement ordering\\n\\n\\n\\t//vars ######################\\n\\tpayableTournament[]\\t\\t\\t\\t\\t\\t\\t\\tprivate\\t_tournaments; //info about tournament and its players\\n\\tmapping(uint256 => user)\\t\\t\\t\\t\\t\\tprivate _users;\\n\\tmapping(address => uint256[]) \\t\\t\\t\\t\\tprivate\\t_ownersOfTournaments; //addresses of creators of tournaments\\n\\tmapping(uint256 => mapping(address => uint256)) private _tournamentBalances; //balance for each participant of the all the tournaments\\n\\tmapping(uint256 => uint256)\\t\\t\\t\\t\\t\\tprivate _tournamentTotalStake; //total amount staked for each tournament\\n\\tuint256\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprivate\\t_current_tournament; //index of last currently created tournament\\n\\tuint256\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tpublic\\tthreshold = 1000000; //min amount that can be proposed as stake\\n\\n\\taddress\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tpublic\\towner;\\n\\t// address \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tpublic\\ttournamentScoresContract;\\n\\t// TournamentScores\\t\\t\\t\\t\\t\\t\\t\\tprivate tournamentScores;\\n\\n\\n\\t//constructor ######################\\n\\tconstructor(address _owner) {\\n\\t\\trequire(_owner != address(0), \\\"owner cannot be zero address!\\\");\\n\\t\\towner = _owner;\\n\\t\\t// if (_tournamentScoresContract == address(0))\\n\\t\\t// \\trevert(\\\"no contract provided\\\");\\n\\n\\t\\t// tournamentScoresContract = _tournamentScoresContract;\\n\\t\\t// tournamentScores = TournamentScores(tournamentScoresContract);\\n\\t}\\n\\n\\n\\n\\n\\n\\n\\t//functions ######################\\n\\n\\n\\n\\t// -------------- PUBLIC (MODIFY STATE) --------------\\n\\n\\t//create a tournament with specific staking -----------------------------------\\n\\t/*\\n\\t\\tone player decides to create a tournament.\\n\\t\\tthis tournament is not yet complete until enough players join (stake).\\n\\t\\tfunction RETURNS the id of tournament,\\n\\t\\twhich can be then used for other players to find it\\n\\t\\tstruct for saving data is payableTournament\\n\\t\\tand it is stored in an array of structs called _tournaments (private)\\n\\t\\t- might make it public;\\n\\t\\tthere is another public tournament array for finished tournaments.\\t\\n\\t*/\\n\\tfunction startPayableTournament(\\n\\t\\tuint256\\t\\t\\t_NofPlayers,\\t\\n\\t\\tuint256\\t\\t\\t_user_id,\\n\\t\\tstring\\tmemory\\t_username,\\n\\t\\taddress\\t\\t\\t_user_wallet,\\n\\t\\tuint256\\t\\t\\t_min_stake\\n\\t) public payable nonReentrant returns(uint256 tournament_id) {\\n\\n\\t\\tif (_NofPlayers > 8)\\n\\t\\t\\trevert numberToHigh(\\\"Too many players\\\", _NofPlayers);\\n\\t\\tif (msg.value < threshold || msg.value < _min_stake)\\n\\t\\t\\trevert insufficientAmount(\\\"insufficient funds allocated, min: \\\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t _min_stake > threshold ? _min_stake : threshold);\\n\\n\\t\\tpayableTournament memory tournament;\\n\\n\\t\\ttournament.min_stake = _min_stake;\\n\\t\\ttournament.stake_goal = _min_stake * _NofPlayers; //stake goal should be sum of minimum stakes from all participants\\n\\t\\ttournament.is_finished = false;\\n\\t\\ttournament.has_started = false;\\n\\t\\ttournament.is_reimbursed = false;\\n\\t\\ttournament.NofPlayers = _NofPlayers;\\n\\t\\ttournament.created_at = block.timestamp;\\n\\t\\ttournament.user_ids[0] = _user_id;\\n\\n\\t\\t//create new user if not stored already\\n\\t\\tif (_users[_user_id].user_id == 0) {\\n\\t\\t\\t_users[_user_id] = user({\\n\\t\\t\\t\\tuser_id: _user_id,\\n\\t\\t\\t\\tusername: _username,\\n\\t\\t\\t\\tuser_wallet: _user_wallet\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\t////save user id in tournament struct\\n\\t\\t//payableTournament storage tour = _tournaments[tournament_id];\\n\\n\\t\\t//uint256 temp_idx;\\n\\t\\t//for (temp_idx = 0; temp_idx < tour.NofPlayers; temp_idx++) {\\n\\t\\t//\\tif (tour.user_ids[temp_idx] == 0)\\n\\t\\t//\\t\\tbreak;\\n\\t\\t//}\\n\\t\\t//if (temp_idx >= tour.NofPlayers) \\n\\t\\t//\\trevert numberToHigh(\\\"Too many players already: \\\", tour.NofPlayers);\\n\\t\\t//tour.user_ids[temp_idx] = _user_id;\\n\\n\\t\\tuint256 id = _tournaments.length;\\n\\t\\t_tournaments.push(tournament);\\n\\t\\t_ownersOfTournaments[msg.sender].push(id);\\n\\t\\t_tournamentBalances[id][msg.sender] = msg.value;\\n\\t\\t_current_tournament = _tournaments.length - 1;\\n\\n\\t\\temit tournamentCreated(\\\"You have successfully created tournament with id: \\\",\\n\\t\\t\\t\\t\\t\\t\\t   _current_tournament -1,\\n\\t\\t\\t\\t\\t\\t\\t   \\\" and staked an amount of: \\\" ,\\n\\t\\t\\t\\t\\t\\t\\t   msg.value);\\n\\t\\treturn(id);\\n\\t}\\n\\n\\t//stake ------------------------------------------------------\\n\\t/*\\n\\t\\tafter tournament is created by the \\\"owner\\\" \\n\\t\\tother participants can apply to the tournament by staking the min amount.\\n\\t\\tnot everyone needs to stake if the stake goal is reached \\n\\t\\t(1 player can stake for the whole tournament if he so desires)\\n\\t\\tif in 10 min stake goal is not reached,\\n\\t\\tthe stakes are returned to player wallets (func. checkTournamentStatus)\\n\\n\\t\\tnew users are saved on chain for better storage management (private)\\n\\n\\t\\tfunction RETURNS the index of the last user who staked,\\n\\t\\tif tournament is already full, returns 0\\n\\t*/\\n\\tfunction stake(uint256\\t\\t\\ttournament_id,\\n\\t\\t\\t\\t   uint256\\t\\t\\t_user_id,\\n\\t\\t\\t\\t   string\\tmemory\\t_username,\\n\\t\\t\\t\\t   address\\t\\t\\t_user_wallet\\n\\t) public payable nonReentrant  returns(uint256 currPlayerIdx) {\\n\\n\\t\\tif (msg.value < threshold || msg.value < _tournaments[tournament_id].min_stake)\\n\\t\\t\\trevert insufficientAmount(\\\"insufficient funds allocated, min: \\\",\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t _tournaments[tournament_id].min_stake > threshold ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\t_tournaments[tournament_id].min_stake \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t: threshold);\\n\\n\\t\\tif (checkTime(tournament_id) == 58008)\\n\\t\\t\\trevert timePassed(\\\"time too stake has passed for tournament: \\\", tournament_id);\\n\\n\\t\\t//save new user data to tournament\\n\\t\\tpayableTournament storage tour = _tournaments[tournament_id];\\n\\t\\tuint256 temp_idx;\\n\\t\\tfor (temp_idx = 0; temp_idx < tour.NofPlayers; temp_idx++) {\\n\\t\\t\\tif (tour.user_ids[temp_idx] == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif (temp_idx < tour.NofPlayers || !tour.has_started)\\n\\t\\t\\ttour.user_ids[temp_idx] = _user_id;\\n\\t\\tif (checkTournamentStatus(tournament_id)) {\\n\\t\\t\\ttour.has_started = true;\\n\\t\\t\\temit tournamentStarted(\\\"tournament has enough players and can start, id: \\\",\\n\\t\\t\\t\\t\\t\\t\\t\\t   tournament_id);\\n\\t\\t\\t\\t\\t\\t\\t\\t   return (0);\\n\\t\\t}\\n\\n\\t\\t//update staked amounts\\n\\t\\tuint256 newTotalStake = _tournamentTotalStake[tournament_id] + msg.value;\\n\\t\\tuint256 refund = newTotalStake > tour.stake_goal ?\\n\\t\\t\\tnewTotalStake - tour.stake_goal : 0;\\n\\t\\tif (refund > 0 && refund <= msg.value)\\n\\t\\t\\tpayable(msg.sender).transfer(refund);\\n\\t\\t_tournamentBalances[tournament_id][msg.sender] += msg.value - refund;\\n\\t\\t_tournamentTotalStake[tournament_id] += msg.value - refund;\\n\\n\\t\\t//create new user if not stored already\\n\\t\\tif (_users[_user_id].user_id == 0) {\\n\\t\\t\\t_users[_user_id] = user({\\n\\t\\t\\t\\tuser_id: _user_id,\\n\\t\\t\\t\\tusername: _username,\\n\\t\\t\\t\\tuser_wallet: _user_wallet\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\n\\t\\temit StakeSuccess(\\\" you have staked to tournament: \\\",\\n\\t\\t\\t\\t\\t\\t  tournament_id,\\n\\t\\t\\t\\t\\t\\t  \\\" amount of: \\\",\\n\\t\\t\\t\\t\\t\\t  msg.value);\\n\\n\\t\\tif (_tournamentTotalStake[tournament_id] >= tour.stake_goal)\\n\\t\\t\\temit StakeGoalReached(\\\" the tournament with id: \\\",\\n\\t\\t\\t\\t\\t\\t\\t\\t  tournament_id,\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\\" has reached the stake amount and is ready to begin, amount: \\\",\\n\\t\\t\\t\\t\\t\\t\\t\\t  _tournamentTotalStake[tournament_id]);\\n\\n\\t\\tif (tour.user_ids.length == tour.NofPlayers){\\n\\t\\t\\ttour.has_started = true;\\n\\t\\t\\temit tournamentStarted(\\\"tournament has enough players and can start, id: \\\",\\n\\t\\t\\t\\t\\t\\t\\t\\t  tournament_id);\\n\\t\\treturn (temp_idx);\\n\\t\\t}\\n\\n\\n\\t}\\n\\n\\t// reimbursement of player who stops before tournament begins -----------------------------------\\n\\t/*\\n\\t\\tit check if user is part of the tournament, if msg.sender is actually this user\\n\\t\\tand then transfers back his stake, only if tournament has not started yet\\n\\t*/\\n\\tfunction reimbursePlayer(uint256 tournament_id, uint256 user_id) public nonReentrant {\\n\\n\\t\\tpayableTournament\\tmemory tour = _tournaments[tournament_id];\\n\\t\\tif (tour.has_started == true)\\n\\t\\t\\trevert tournamentInProgress(\\\"can't execute because tournament already started, id: \\\", tournament_id);\\n\\t\\tmapping(address => uint256) storage balances = _tournamentBalances[tournament_id];\\n\\t\\taddress\\tuser_wallet = address(0);\\n\\n\\t\\tfor (uint256 i  = 0; i < tour.NofPlayers; i++) {\\n\\t\\t\\tif (tour.user_ids[i] == user_id) {\\n\\t\\t\\t\\tuser_wallet = _users[user_id].user_wallet;\\n\\t\\t\\t\\tbreak ;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (user_wallet == address(0) || user_wallet != msg.sender)\\n\\t\\t\\trevert wrongUser(\\\"this user is not a part of the tournament: \\\", user_id);\\n\\n\\t\\tuint256 refundAmount = balances[user_wallet];\\n\\t\\tpayable(user_wallet).transfer(refundAmount);\\n\\t\\tbalances[user_wallet] -= refundAmount;\\n\\t\\tdeletePlayer(tournament_id, user_id);\\n\\n\\t}\\n\\n\\t// reimburse if tournament didn't start -----------------------------------------------\\n\\t/*\\n\\t\\tany participant can run this function if they are participating in the tournament\\n\\t\\tit reimburses all the tournament participants, only if tournament could't start\\n\\t*/\\n\\tfunction reimburseIfFailedStart(uint256 tournament_id, uint256 user_id) public nonReentrant {\\n\\n\\t\\tpayableTournament memory tour = _tournaments[tournament_id];\\n\\t\\tuint256 i;\\n\\t\\tfor(i = 0; i < tour.NofPlayers; i++) {\\n\\t\\t\\tuser memory u = _users[user_id];\\n\\t\\t\\tif (tour.user_ids[i] == user_id && u.user_wallet == msg.sender)\\n\\t\\t\\t\\tbreak ;\\n\\t\\t}\\n\\t\\tuint256 time_passed = checkTime(tournament_id);\\n\\t\\tif (i == tour.NofPlayers)\\n\\t\\t\\trevert wrongUser(\\\"user can't execute this process, user id: \\\", user_id);\\n\\t\\tif (tour.has_started)\\n\\t\\t\\trevert tournamentInProgress(\\\"tournament is already in progress, id: \\\", tournament_id);\\n\\t\\tif (!tour.is_finished && !tour.is_reimbursed && time_passed == 58008)\\n\\t\\t\\treimburseAll(tournament_id, \\\"tournament could't start, reimbursing all stakes\\\");\\n\\t}\\n\\n\\t//save tournament data and distribute prizes ----------------------------------------------\\n\\t/*\\n\\t\\twe do it after we know the tournament is finished, \\n\\t\\tonly the one who created the tournament can post data to blockchain, \\n\\t\\tto protect against spoofing, and duplicate transactions\\n\\t\\tlogic for storing finished tournament data is inherited from TournamentScores contract\\n\\n\\t\\tthe balances are rearanged based on tournament placement and redistributed (90%)\\n\\t\\t9% goes to contract owner, 1% goes to tournament owner for gas fees\\n\\n\\t*/\\n\\tfunction saveResultsAndTransferToken(uint256[8]\\tmemory\\tuser_scores,\\n\\t\\t\\t\\t\\t\\t uint256[8]\\tmemory\\tuser_ids,\\n\\t\\t\\t\\t\\t\\t uint256\\t\\t\\t\\ttournament_id\\n\\t)\\tpublic nonReentrant {\\n\\n\\t\\tif (_tournaments.length <= tournament_id)\\n\\t\\t\\trevert indexOutOfBounds(\\\"Tournament_id is to high, max id is: \\\", _tournaments.length -1);\\n\\t\\tpayableTournament\\tmemory tour = _tournaments[tournament_id];\\n\\t\\tuint256[] \\t\\t\\tmemory\\townedTournaments = _ownersOfTournaments[msg.sender];\\n\\t\\tbool\\t\\t\\t\\t\\t\\tis_owner = false;\\n\\t\\tif (tour.is_finished || tour.is_reimbursed)\\n\\t\\t\\trevert tournamentAlreadyFinished(\\n\\t\\t\\t\\t\\\"Tournament is still in progress or was already reimbursed, tournament id: \\\",\\n\\t\\t\\t\\ttournament_id\\n\\t\\t\\t);\\n\\n\\t\\tfor (uint256 i = 0; i < ownedTournaments.length; i++){\\n\\t\\t\\tif (ownedTournaments[i] == tournament_id) {\\n\\t\\t\\t\\tis_owner = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (!is_owner)\\n\\t\\t\\trevert wrongUser(\\\"Sender is not the owner of the tournament: \\\", tournament_id);\\n\\n\\t\\t//organize user_ids and scores if not same as saved on chain\\n\\t\\tuint256[8] memory reorder_scores;\\n\\t\\tfor (uint256 i = 0; i < tour.NofPlayers; i++) {\\n\\t\\t\\tfor (uint256 j = 0; j < tour.NofPlayers; j++) {\\n\\t\\t\\t\\tif (tour.user_ids[i] == user_ids[j]) {\\n\\t\\t\\t\\t\\treorder_scores[i] = user_scores[j];\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (reorder_scores.length != user_scores.length)\\n\\t\\t\\trevert wrongUsersPassed(\\\"the users passed, are not the same as saved on chain. user_ids on chain: \\\", tour.user_ids);\\n\\n\\t\\t//concat winning_names into one string\\n\\t\\tuint256[8][8] memory placements = tournamentPlacement(reorder_scores, tour.user_ids);\\n\\t\\tstring memory winning_names;\\n\\t\\tfor (uint256 i = 0; i < placements[0].length - 1; i++) {\\n\\t\\t\\tuser memory u = _users[tour.user_ids[i]];\\n            winning_names = string(abi.encodePacked(winning_names, u.username, \\\";\\\"));\\n\\t\\t}\\n\\t\\tuser memory usr = _users[tour.user_ids[user_ids.length -1]];\\n\\t\\twinning_names = string(abi.encodePacked(winning_names, usr.username));\\n\\n\\t\\t//save the correct data to TournamentScores contract\\n\\t\\tsaveTournamentData(tour.NofPlayers,\\n\\t\\t\\t\\t\\t\\t\\ttour.user_ids,\\n\\t\\t\\t\\t\\t\\t\\treorder_scores,\\n\\t\\t\\t\\t\\t\\t\\tplacements[0],\\n\\t\\t\\t\\t\\t\\t\\twinning_names,\\n\\t\\t\\t\\t\\t\\t\\ttournament_id);\\n\\n\\t\\t//TRANSFERS\\n\\t\\t//only change tournament balances\\n\\t\\tdistributePrizes(tournament_id, placements);\\n\\t\\t//transfer 1% to tournament owner - reimburse gasfees\\n\\t\\tpayable(msg.sender).transfer(tour.stake_goal / 100);\\n\\t\\t//transfer the new balances back to players\\n\\t\\treimburseAll(tournament_id, \\n\\t\\t\\t\\t\\t \\\"Tournament finished, all players have received their winnings\\\");\\n\\t\\t//transfer rest\\n\\t\\ttransferRestToOwner(tournament_id, tour);\\n\\t\\t\\n\\t}\\n\\n\\t\\n\\n\\n\\n\\t// -----------------PUBLIC VIEW ONLY --------------------------\\n\\n\\t//check if goal is reached --------------------------------------------------- \\n\\t/*\\n\\t\\ta view only function that RETURNS true if the stake goal is reached\\n\\t*/\\n\\tfunction\\tisGoalReached(uint256 tournament_id) public view returns(bool isReached) {\\n\\n\\t\\tif (_tournaments.length <= tournament_id)\\n\\t\\t\\trevert indexOutOfBounds(\\\"Tournament_id is to high, max id is: \\\", _tournaments.length -1);\\n\\n\\t\\tpayableTournament memory tour = _tournaments[tournament_id];\\n\\n\\t\\tif (_tournamentTotalStake[tournament_id] >= tour.stake_goal)\\n\\t\\t\\treturn (true);\\n\\t\\treturn (false);\\n\\t}\\n\\n\\t//check if tournament is finished already ------------------------------------------\\n\\t/*\\n\\t\\treturns true if the tournament already concluded\\n\\t*/\\n\\tfunction isTournamentFinished(uint256 tournament_id) public view returns(bool isFinished) {\\n\\n\\t\\tif (_tournaments.length <= tournament_id)\\n\\t\\t\\trevert indexOutOfBounds(\\\"Tournament_id is to high, max id is: \\\", _tournaments.length -1);\\n\\n\\t\\tpayableTournament memory tour = _tournaments[tournament_id];\\n\\n\\t\\tif (tour.is_finished)\\n\\t\\t\\treturn (true);\\n\\t\\treturn (false);\\n\\t}\\n\\n\\t//check if all players have applied ---------------------------------------------------\\n\\t/*\\n\\t\\treturns true if all players have signed up for the tournament\\n\\t*/\\n\\tfunction hasAllPlayers(uint256 tournament_id) public view returns(bool hasAll) {\\n\\t\\t\\n\\t\\tif (_tournaments.length <= tournament_id)\\n\\t\\t\\trevert indexOutOfBounds(\\\"Tournament_id is to high, max id is: \\\", _tournaments.length -1);\\n\\n\\t\\tpayableTournament memory tour = _tournaments[tournament_id];\\n\\n\\t\\tuint256 i = 0;\\n\\t\\tfor (i = 0; i < tour.NofPlayers; i++) {\\n\\t\\t\\tif (tour.user_ids[i] == 0)\\n\\t\\t\\t\\treturn (false);\\n\\t\\t}\\n\\t\\tif (i != tour.NofPlayers)\\n\\t\\t\\treturn (false);\\n\\t\\treturn (true);\\n\\t}\\n\\n\\t// check if we need to reimburse or continue with tournament ---------------------------\\n\\t/*\\n\\t\\treturns true if the tournament can start (enough players,\\n\\t\\tstake goal reached, if it was already played).\\n\\t\\tputs a timelimit of 10min for the staking of tournament to conclude,\\n\\t\\totherwise reimburses automatically\\n\\t*/\\n\\tfunction checkTournamentStatus(uint256 tournament_id) public view returns(bool canStart) {\\n\\n\\t\\tif (_tournaments.length <= tournament_id)\\n\\t\\t\\trevert indexOutOfBounds(\\\"Tournament_id is to high, max id is: \\\", _tournaments.length -1);\\n\\t\\t\\n\\t\\tif (isTournamentFinished(tournament_id))\\n\\t\\t\\treturn (false);\\n\\n\\t\\tpayableTournament memory tour = _tournaments[tournament_id];\\n\\t\\tbool start = false;\\n\\n\\t\\t//time check and reimbursement\\n\\t\\tif (block.timestamp > tour.created_at + 10 minutes) {\\n\\t\\t\\t// emit timeForStakePassed(\\\"time to gather funds for tournament has passed\\\");\\n\\t\\t\\t// reimburseAll(tournament_id, \\\"the stakes have been reimbursed, tournament didn't start\\\");\\n\\t\\t\\treturn (false);\\n\\t\\t}\\n\\n\\t\\tif (isGoalReached(tournament_id))\\n\\t\\t\\tstart = true;\\n\\t\\tif (!hasAllPlayers(tournament_id))\\n\\t\\t\\tstart = false;\\n\\n\\t\\treturn (start);\\n\\t}\\n\\n\\t//check time remaining for staking (max 10min) ------------------------------\\n\\t/*\\n\\t\\treturns how much time is still remaining,\\n\\t\\totherwise returns 58008 if time for staking has passed\\n\\t*/\\n\\tfunction checkTime(uint256 tournament_id) public view returns(uint256 timeRemaining) {\\n\\t\\tif (_tournaments.length <= tournament_id)\\n\\t\\t\\trevert indexOutOfBounds(\\\"Tournament_id is to high, max id is: \\\", _tournaments.length -1);\\n\\t\\tuint256 elapsed_time = block.timestamp - _tournaments[tournament_id].created_at;\\n\\n\\t\\treturn (elapsed_time < 10 minutes ?\\n\\t\\t\\t\\t\\t(10 minutes - elapsed_time) / 60\\n\\t\\t\\t\\t\\t: 58008);\\n\\t}\\n\\n\\n\\n\\n\\n\\t// -----------------------PRIVATE --------------------------------\\n\\n\\n\\t// ---------money transfers ----------------------\\n\\n\\t// reimburse all players of the tournament ---------------------------------\\n\\tfunction reimburseAll(uint256 tournament_id, string memory err_msg) private {\\n\\n\\t\\tpayableTournament storage tour = _tournaments[tournament_id];\\n\\t\\tmapping(address => uint256) storage balances = _tournamentBalances[tournament_id];\\n\\n\\t\\tfor (uint64 i = 0; i < tour.NofPlayers; i++) {\\n\\t\\t\\tuser memory curr_user = _users[tour.user_ids[i]];\\n\\t\\t\\tuint256 \\tbalance = balances[curr_user.user_wallet];\\n\\t\\t\\tif (balance > 0) {\\n\\t\\t\\t\\tpayable(curr_user.user_wallet).transfer(balance);\\n\\t\\t\\t\\tbalances[curr_user.user_wallet] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ttour.is_reimbursed = true;\\n\\t\\ttour.is_finished = true;\\n\\t\\t_tournamentTotalStake[tournament_id] = 0;\\n\\t\\temit reimbursedStakes(err_msg);\\n\\t}\\n\\n\\tfunction transferRestToOwner(uint256 tournament_id, payableTournament memory tour) private {\\n\\n\\t\\tmapping(address => uint256) storage balances = _tournamentBalances[tournament_id];\\n\\t\\tuint256[8] memory ids = tour.user_ids;\\n\\t\\tuint256\\t\\t\\t  ownerShare = (tour.stake_goal * 9) / 100;\\n\\n\\t\\tpayable(owner).transfer(ownerShare);\\n\\t\\tfor (uint256 i = 0; i < ids.length; i++) {\\n\\t\\t\\taddress currAddress = _users[ids[i]].user_wallet;\\n\\t\\t\\tif (balances[currAddress] > 0)\\n\\t\\t\\t\\tpayable(owner).transfer(balances[currAddress]);\\n\\t\\t\\tbalances[currAddress] = 0;\\n\\t\\t}\\n\\t\\t \\n\\t\\temit restTransferToOwner(\\n\\t\\t\\t\\\"the rest of the tournament stake has been transferred to contract owner\\\"\\n\\t\\t);\\n\\n\\t}\\n\\n\\t// ---------------------other helper functions ---------------------\\n\\n\\n\\t// distribute prizes ------------------------------------------------\\n\\t/*\\n\\t\\tdistribute prizes based on tournament score\\n\\t\\ttotal prize pool 90% of stake 10% to the house\\n\\t\\t1st place 50% (of prize pool, not total staked amount)\\n\\t\\t2nd 30%\\n\\t\\t3rd 15%\\n\\t\\t4th 5%\\n\\t\\tif more players have the same ranking this also gets calculated fairly\\n\\t\\tex: 2 first places (50% + 30%) = 80%, so each get 40%,\\n\\t\\tthe first on second place then gets 15%\\n\\t\\tnote: this just changes the balances of players, no transfer yet\\n\\t*/\\n\\tfunction distributePrizes(uint256 tournament_id, uint256[8][8] memory placements) private {\\n\\n\\t\\tpayableTournament memory tour = _tournaments[tournament_id];\\n\\t\\tmapping(address => uint256) storage balances = _tournamentBalances[tournament_id];\\n\\t\\tuint256\\tprizePool = (tour.stake_goal * 9) / 10;\\n        uint256[] memory percentages = new uint256[](4);\\n        percentages[0] = 50;\\n        percentages[1] = 30;\\n        percentages[2] = 15;\\n        percentages[3] = 5;\\n\\n\\t\\tuint256 percentIdx = 0;\\n\\t\\tuint256 totalPercentage = 0;\\n\\t\\tuint256 personalPercentage = 0;\\n\\t\\tuint256 currId = 0;\\n\\t\\tuint256\\tsharedPlacementUsers = 0;\\n\\t\\tfor (uint256 i = 0; i < placements.length; i++) {\\n\\t\\t\\tfor (uint256 j = 0; j < placements[i].length; j++) {\\n\\t\\t\\t\\tif (placements[i][j] == 0)\\n\\t\\t\\t\\t\\tbreak ;\\n\\t\\t\\t\\telse if (percentIdx < percentages.length) {\\n\\t\\t\\t\\t\\ttotalPercentage += percentages[percentIdx++];\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsharedPlacementUsers++;\\n\\t\\t\\t}\\n\\t\\t\\tpersonalPercentage = totalPercentage > 0 && sharedPlacementUsers > 0 ?\\n\\t\\t\\t\\t\\ttotalPercentage / sharedPlacementUsers \\n\\t\\t\\t\\t\\t: 0;\\n\\t\\t\\tfor (uint256 k = 0; k < sharedPlacementUsers; k++) {\\n\\t\\t\\t\\tcurrId = placements[i][k];\\n\\t\\t\\t\\tuser\\tstorage currUser = _users[currId];\\n\\t\\t\\t\\tbalances[currUser.user_wallet] = (prizePool * personalPercentage) / 100;\\n\\t\\t\\t}\\n\\t\\t\\ttotalPercentage = 0;\\n\\t\\t\\tpersonalPercentage = 0;\\n\\t\\t\\tsharedPlacementUsers = 0;\\n\\t\\t\\tif (percentIdx >= percentages.length)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\n \\n\\t//placement in tournament (first to last) -----------------------------------\\n\\t/*\\n\\t\\tused for distributing prizes fairly and for saving  tournament results to blockchain\\n\\t\\treturns a 2d array of fixed size 8x8 where arr[0] is all who placed first (if same score),\\n\\t\\tarr[1] are who placed 2nd, and so on ....\\n\\t*/\\n\\tfunction tournamentPlacement(uint256[8]\\tmemory\\tuser_scores,\\n\\t\\t\\t\\t\\t\\t\\t\\t uint256[8]\\tmemory\\tuser_ids\\n\\t)\\tprivate pure returns(uint256[8][8] memory placements) {\\n\\n\\t\\t//populate\\n\\t\\tPair[8] memory\\tpairs;\\n\\t\\tfor (uint64\\ti = 0; i < user_scores.length; i++) {\\n\\t\\t\\tpairs[i] = Pair(user_scores[i], user_ids[i]);\\n\\t\\t}\\n\\n\\t\\t//sort\\n\\t\\tfor (uint256 i = 0; i < pairs.length; i++) {\\n\\t\\t\\tPair memory curr = pairs[i];\\n\\t\\t\\tuint256 j = i;\\n\\t\\t\\twhile (j > 0 && pairs[j - 1].user_score < curr.user_score) {\\n\\t\\t\\t\\tpairs[j] = pairs[j-1];\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tpairs[j] = curr;\\n\\t\\t}\\n\\n\\t\\t//put in correct placement\\n\\t\\tuint256 placement = 0;\\n\\t\\tuint256 idx = 0;\\n\\t\\tfor (uint256 i = 0; i < pairs.length; i++) {\\n\\t\\t\\tif (i == 0 || pairs[i].user_score == pairs[i -1].user_score) {\\n\\t\\t\\t\\tplacements[placement][idx++] = pairs[i].user_id;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tidx = 0;\\n\\t\\t\\t\\tplacement++;\\n\\t\\t\\t\\tplacements[placement][idx++] = pairs[i].user_id;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn (placements);\\n\\t}\\n\\n\\n\\t// delete player from tournament -------------------------------\\n\\t/*\\n\\t\\tused when a player decides to step out of tournament before it starts.\\n\\t\\tit resets the number of players pushing all of them one place to the start\\n\\t\\tfrom user_id index in the array\\n\\t*/\\n\\tfunction deletePlayer(uint256 tournament_id, uint256 user_id) private {\\n\\n\\t\\tpayableTournament storage tour = _tournaments[tournament_id];\\n\\n\\t\\tfor (uint256 i = 0; i < tour.NofPlayers; i++) {\\n\\t\\t\\tif (tour.user_ids[i] == user_id) {\\n\\t\\t\\t\\tfor (uint256 j = i + 1; j < tour.NofPlayers; j++) {\\n\\t\\t\\t\\t\\ttour.user_ids[j - 1] = tour.user_ids[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif (tour.user_ids[i] == 0)\\n\\t\\t\\t\\tbreak ;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\n\\t//withdraw -- might not do the withdraw function - \\n\\t// so only after tournaments can owner get his share, and not just take what he wants\\n\\n\\n}\\n\"},\"TournamentScores.sol\":{\"content\":\"// SPDX-License-Identifier: Ecosystem\\n\\npragma solidity 0.8.25;\\n\\n\\t//get all the tournaments player was in //TODO\\ncontract TournamentScores {\\n\\n\\t//events\\n\\tevent tournamentDataSaved(string msg, uint256 tournament_id);\\n\\n\\t//errors\\n\\terror numberToHigh(string msg, uint256 NofPlayers);\\n\\terror indexOutOfBounds(string msg, uint256 passedIndex);\\n\\n\\t//structs\\n\\tstruct tournament {\\n\\t\\tuint256[8]\\tuser_ids;\\n\\t\\taddress[8]\\tuser_wallets;\\n\\t\\tuint256[8] \\tuser_scores;\\n\\t\\tuint256[8]\\twinner_ids;\\n\\t\\tstring\\t\\twinner_names;\\n\\t\\tuint256\\t\\ttournament_id;\\n\\t}\\n\\n\\n\\t//vars\\n\\t// tournament[]\\t\\t\\tpublic\\ttournament_registry;\\n\\tmapping(uint256 => tournament) public tournament_registry;\\n\\tuint256\\t\\t\\t\\t\\tprivate _current_tournament; //when a turnament is played it will have this index\\t \\n\\n\\t//constructor\\n\\n\\t//functions\\n\\n\\t//saves new entry for a completed tournament\\n\\tfunction saveTournamentData(\\n\\t\\tuint256\\t\\t\\t\\t_NofPlayers,\\t\\n\\t\\tuint256[8]\\tmemory\\t_user_ids,\\n\\t\\tuint256[8]\\tmemory\\t_user_scores,\\n\\t\\tuint256[8]\\tmemory\\t_winner_ids,\\n\\t\\tstring\\t\\tmemory\\t_winner_names,\\n\\t\\tuint256\\t\\t\\t\\t_tournament_id\\n\\t)\\tpublic {\\n\\n\\t\\tif (_NofPlayers > 8)\\n\\t\\t\\trevert numberToHigh(\\\"Too many players\\\", _NofPlayers);\\n\\n\\t\\ttournament storage t = tournament_registry[_tournament_id];\\n\\t\\t\\n\\t\\tfor (uint256 i = 0; i < _NofPlayers; i++) {\\n\\t\\t\\tt.user_ids[i] = _user_ids[i];\\n\\t\\t\\tt.user_scores[i] = _user_scores[i];\\n\\t\\t}\\n\\t\\tt.winner_ids = _winner_ids;\\n\\t\\tt.winner_names = _winner_names;\\n\\t\\tt.tournament_id = _tournament_id;\\n\\t\\t_current_tournament++;\\n\\t\\temit tournamentDataSaved(\\\"all neccesarry data for a tournament has been saved. tournament id: \\\", _tournament_id);\\n\\t}\\n\\n\\t//returns a tournament with specified idx as a tuple (can be parsed as JSON in frontend)\\n\\tfunction getTournamentData(uint256 tournamentIndex) public view returns (\\n\\t\\tuint256[8] memory,\\n\\t\\tuint256[8] memory,\\n\\t\\tuint256[8] memory,\\n\\t\\tstring memory,\\n\\t\\tuint256\\n\\t) {\\n\\n\\t\\tif (tournamentIndex >= _current_tournament)\\n\\t\\t\\trevert indexOutOfBounds(\\\"index of turnament is out of bounds. Max index: \\\", _current_tournament);\\n\\n\\t\\ttournament memory t = tournament_registry[tournamentIndex];\\n\\t\\treturn (\\n\\t\\t\\tt.user_ids,\\n\\t\\t\\tt.user_scores,\\n\\t\\t\\tt.winner_ids,\\n\\t\\t\\tt.winner_names,\\n\\t\\t\\tt.tournament_id\\n\\t\\t);\\n\\t}\\n\\n\\t//get all the tournaments player was in //TODO\\n\\n\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\\n * consider using {ReentrancyGuardTransient} instead.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"},\"ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS\\n    }\\n\\n    /**\\n     * @dev The signature derives the `address(0)`.\\n     */\\n    error ECDSAInvalidSignature();\\n\\n    /**\\n     * @dev The signature has an invalid length.\\n     */\\n    error ECDSAInvalidSignatureLength(uint256 length);\\n\\n    /**\\n     * @dev The signature has an S value that is in the upper half order.\\n     */\\n    error ECDSAInvalidSignatureS(bytes32 s);\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\\n     * and a bytes32 providing additional information about the error.\\n     *\\n     * If no error is returned, then the address can be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly (\\\"memory-safe\\\") {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[ERC-2098 short signatures]\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\\n        unchecked {\\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\\n            return tryRecover(hash, v, r, s);\\n        }\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS, s);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\\n        }\\n\\n        return (signer, RecoverError.NoError, bytes32(0));\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\\n        _throwError(error, errorArg);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\\n     */\\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert ECDSAInvalidSignature();\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert ECDSAInvalidSignatureS(errorArg);\\n        }\\n    }\\n}\\n\"}}}"}
